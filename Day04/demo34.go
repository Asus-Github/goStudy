package main

import "fmt"

/*
闭包：内层函数操作外层函数的变量
在闭包结构中:局部变量的生命周期就会发生改变，
正常的局部变量会随着函数的调用而创建，随着函数的结束而销毁
但是闭包结构中的外层函数的局部变量并不会随着外层兩数的结束而销毁，因为内层函数还在继续使用

很多第三方库变量都采用闭包，原因是避免与用户使用的变量冲突
闭包可能导致内存泄漏 （因为并不会随外层函数的销毁而销毁，因为内层函数还在继续使用）
内存泄漏：
是指你向系统申请分配内存进行使用（new/malloc），然后系统在堆内存中给这个对象申请一块内存空间
但当我们使用完了却没有归系统（delete），导致这个不使用的对象一直占据内存单元，造成系统将不能再把它分配给需要的程序。
一次内存泄漏的危害可以忽略不计，但是内存泄漏堆积则后果很严重，无论多少内存，迟早会被占完，造成内存泄漏。
*/
func main() {

	f1 := bibao()

	x1 := f1()
	fmt.Println(x1)
	x2 := f1()
	fmt.Println(x2)
	x3 := f1()
	fmt.Println(x3)
	fmt.Println("-----------------------")
	f2 := bibao() //二次调用 i=0
	y1 := f2()
	fmt.Println(y1)
	x4 := f1() //这里的i并没有随着第二次创建就归0，而是在内层函数继续调用着  外层死了，内层函数没死，i还在被内层函数用着，i依然存在内存中
	fmt.Println(x4)
	//查看地址
	fmt.Printf("%p\n", &f1)
	fmt.Printf("%p", &f2)

}

func bibao() func() int {
	i := 0
	f := func() int {
		i++
		return i
	}
	return f
}
