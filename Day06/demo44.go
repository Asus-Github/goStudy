package main

import "fmt"

/*
在 Go 语言中，数组（array）是值类型，而切片（slice）是引用类型。
*/
func main() {

	arr := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	fmt.Println(arr)
	updata1(arr)
	fmt.Println(arr)
	s1 := arr[:]
	updata2(s1)
	fmt.Println(s1)
}

/*
这里 arr [10]int 作为参数，是值传递，所以 updata1 接收的是原数组的一份拷贝，不会修改原数组。
传参时，整个 arr 数组会被 完整复制一份 传入 updata1，所以 updata1 里 arr[1] = 100 只是修改了副本，不会影响原 arr。
数组的大小是固定的，它的内存分配在栈上
当你将数组作为参数传递时，Go 会复制整个数组。这意味着：
原数组的所有数据都被复制到函数的栈空间中，并且这个副本是一个独立的对象。
对副本的修改不会影响原数组。
记住数组是值传递就行了 ⭐可以理解为值传递把数据存在了这个函数的栈中，函数结束，数据栈也销毁了，所以修改无效，所以更多的是传地址 user &User 进行修改信息
*/
func updata1(arr [10]int) {
	arr[1] = 100
}

/*
那在实际开发中，我有时候并不能确定用户传过来的数据有多少，那怎么确定数组大小呢？
问题：如何处理不固定大小的数组？
使用切片 []int（推荐）
Go 语言推荐使用 切片（slice） 代替数组，切片的长度是动态的，不需要提前确定：
func updateSlice(s []int) {
	s[1] = 100 // 直接修改底层数组
}
为什么使用切片？
切片可以接受任意长度的数组。
切片是引用类型，可以修改底层数组数据。
切片的长度和容量是动态的，可以 append 扩展。
切片的底层仍然是数组，但不需要手动管理数组大小。

*/

/*
切片（slice）是引用类型，所以 s 不是拷贝数组，而是指向原数组的视图。当 s[1] = 100 时，修改的是 arr 的底层数组，所以原数组被修改。
*/
func updata2(s []int) {
	s[1] = 100
}

//即数组是值传递，传递的是一份copy的数组，切片是引用，切片本质上存储了对底层数组的指针、长度和容量。
//切片本身就是个指针
